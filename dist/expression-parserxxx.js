const parserSyntax=require("./parserSyntax");require("@nexssp/extend");const expressionParser2=e=>{if(!e)return e;let r=JSON.stringify(e);parserSyntax.forEach((e=>{r=r.replace(e.match,e.replace)}));let s,a=new Set;try{s=r.interpolate(e)}catch(r){let s=[];if(r.message.includes("is not defined")){const a=r.message.split(" ")[0];Object.keys(e).forEach((e=>{a.similarity(e)>50&&s.push(e)}))}a.add(`Some of your \${} expression has an error.\nError message: ${bold(r.message)} ${s?`\nDid you meant: ${bold(s.join(" or "))}?`:""}`)}return a.size>0&&(a.forEach((e=>{log.error(e)})),process.exit(0)),JSON.parse(s.replace(/\\/g,"\\\\"))},expressionParser=(e,r)=>{if(Array.isArray(r))return r.map((r=>expressionParser(e,r)));let s=new Set;if(r&&isNaN(r)&&r.includes&&r.includes("${"))try{return r.interpolate(e)}catch(a){let o=[];if(a.message.includes("is not defined")){const r=a.message.split(" ")[0];Object.keys(e).forEach((e=>{r.similarity(e)>50&&o.push(e)}))}s.add("=".repeat(80)),s.add(bold(`\tError in parsing expression: ${r},`)+red(bold(`\n\tError message: ${yellow(bold(a.message))}`))+` ${o&&o.length>0?blue(`\nDid you meant: ${o.join(" or ")}?`):""}`),s.add(e)}return s.size>0&&(s.forEach((e=>{log.error(e)})),process.exit(0)),r};module.exports.expressionParser=expressionParser;